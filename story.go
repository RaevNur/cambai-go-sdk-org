// This file was auto-generated by Fern from our API Definition.

package cambai

import (
	json "encoding/json"
	fmt "fmt"
	core "sdk/core"
	time "time"
)

type BodyCreateStoryStoryPost struct {
	RunID              *int      `json:"-" url:"run_id,omitempty"`
	SourceLanguage     Languages `json:"source_language" url:"source_language"`
	Title              *string   `json:"title,omitempty" url:"title,omitempty"`
	Description        *string   `json:"description,omitempty" url:"description,omitempty"`
	NarratorVoiceID    *int      `json:"narrator_voice_id,omitempty" url:"narrator_voice_id,omitempty"`
	FolderID           *int      `json:"folder_id,omitempty" url:"folder_id,omitempty"`
	ChosenDictionaries []int     `json:"chosen_dictionaries,omitempty" url:"chosen_dictionaries,omitempty"`
}

type GetStoriesRunsResultsStoriesResultsPostRequest struct {
	Traceparent *string               `json:"-" url:"-"`
	RunID       *int                  `json:"-" url:"run_id,omitempty"`
	Body        *RunIDsRequestPayload `json:"-" url:"-"`
}

func (g *GetStoriesRunsResultsStoriesResultsPostRequest) UnmarshalJSON(data []byte) error {
	body := new(RunIDsRequestPayload)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	g.Body = body
	return nil
}

func (g *GetStoriesRunsResultsStoriesResultsPostRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(g.Body)
}

type GetStoryRunInfoStoryResultRunIDGetRequest struct {
	// Whether to include the transcription in the response for fetching the result of a Stories run.
	IncludeTranscript *bool `json:"-" url:"include_transcript,omitempty"`
}

type GetStoryStatusStoryTaskIDGetRequest struct {
	RunID *int `json:"-" url:"run_id,omitempty"`
}

type BodySetupStoryStorySetupPost struct {
	RunID              *int      `json:"-" url:"run_id,omitempty"`
	SourceLanguage     Languages `json:"source_language" url:"source_language"`
	Title              *string   `json:"title,omitempty" url:"title,omitempty"`
	Description        *string   `json:"description,omitempty" url:"description,omitempty"`
	NarratorVoiceID    *int      `json:"narrator_voice_id,omitempty" url:"narrator_voice_id,omitempty"`
	FolderID           *int      `json:"folder_id,omitempty" url:"folder_id,omitempty"`
	ChosenDictionaries []int     `json:"chosen_dictionaries,omitempty" url:"chosen_dictionaries,omitempty"`
}

type GetSetupStoryResultResponse struct {
	RunID        int           `json:"run_id" url:"run_id"`
	StoryDetails *StoryDetails `json:"story_details,omitempty" url:"story_details,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSetupStoryResultResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSetupStoryResultResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSetupStoryResultResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSetupStoryResultResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type StoryDetails struct {
	StoryTitle       string      `json:"story_title" url:"story_title"`
	StoryDescription *string     `json:"story_description,omitempty" url:"story_description,omitempty"`
	CreatedAt        time.Time   `json:"created_at" url:"created_at"`
	SourceLanguage   Languages   `json:"source_language" url:"source_language"`
	TargetLanguages  []Languages `json:"target_languages,omitempty" url:"target_languages,omitempty"`
	FolderID         *int        `json:"folder_id,omitempty" url:"folder_id,omitempty"`
	StudioURL        string      `json:"studio_url" url:"studio_url"`

	_rawJSON json.RawMessage
}

func (s *StoryDetails) UnmarshalJSON(data []byte) error {
	type embed StoryDetails
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = StoryDetails(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StoryDetails) MarshalJSON() ([]byte, error) {
	type embed StoryDetails
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed:     embed(*s),
		CreatedAt: core.NewDateTime(s.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (s *StoryDetails) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type CreateStoryStoryPostResponse struct {
	typeName                       string
	OrchestratorPipelineCallResult *OrchestratorPipelineCallResult
	GetSetupStoryResultResponse    *GetSetupStoryResultResponse
}

func NewCreateStoryStoryPostResponseFromOrchestratorPipelineCallResult(value *OrchestratorPipelineCallResult) *CreateStoryStoryPostResponse {
	return &CreateStoryStoryPostResponse{typeName: "orchestratorPipelineCallResult", OrchestratorPipelineCallResult: value}
}

func NewCreateStoryStoryPostResponseFromGetSetupStoryResultResponse(value *GetSetupStoryResultResponse) *CreateStoryStoryPostResponse {
	return &CreateStoryStoryPostResponse{typeName: "getSetupStoryResultResponse", GetSetupStoryResultResponse: value}
}

func (c *CreateStoryStoryPostResponse) UnmarshalJSON(data []byte) error {
	valueOrchestratorPipelineCallResult := new(OrchestratorPipelineCallResult)
	if err := json.Unmarshal(data, &valueOrchestratorPipelineCallResult); err == nil {
		c.typeName = "orchestratorPipelineCallResult"
		c.OrchestratorPipelineCallResult = valueOrchestratorPipelineCallResult
		return nil
	}
	valueGetSetupStoryResultResponse := new(GetSetupStoryResultResponse)
	if err := json.Unmarshal(data, &valueGetSetupStoryResultResponse); err == nil {
		c.typeName = "getSetupStoryResultResponse"
		c.GetSetupStoryResultResponse = valueGetSetupStoryResultResponse
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateStoryStoryPostResponse) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "orchestratorPipelineCallResult":
		return json.Marshal(c.OrchestratorPipelineCallResult)
	case "getSetupStoryResultResponse":
		return json.Marshal(c.GetSetupStoryResultResponse)
	}
}

type CreateStoryStoryPostResponseVisitor interface {
	VisitOrchestratorPipelineCallResult(*OrchestratorPipelineCallResult) error
	VisitGetSetupStoryResultResponse(*GetSetupStoryResultResponse) error
}

func (c *CreateStoryStoryPostResponse) Accept(visitor CreateStoryStoryPostResponseVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "orchestratorPipelineCallResult":
		return visitor.VisitOrchestratorPipelineCallResult(c.OrchestratorPipelineCallResult)
	case "getSetupStoryResultResponse":
		return visitor.VisitGetSetupStoryResultResponse(c.GetSetupStoryResultResponse)
	}
}

type SetupStoryStorySetupPostResponse struct {
	typeName                       string
	OrchestratorPipelineCallResult *OrchestratorPipelineCallResult
	GetSetupStoryResultResponse    *GetSetupStoryResultResponse
}

func NewSetupStoryStorySetupPostResponseFromOrchestratorPipelineCallResult(value *OrchestratorPipelineCallResult) *SetupStoryStorySetupPostResponse {
	return &SetupStoryStorySetupPostResponse{typeName: "orchestratorPipelineCallResult", OrchestratorPipelineCallResult: value}
}

func NewSetupStoryStorySetupPostResponseFromGetSetupStoryResultResponse(value *GetSetupStoryResultResponse) *SetupStoryStorySetupPostResponse {
	return &SetupStoryStorySetupPostResponse{typeName: "getSetupStoryResultResponse", GetSetupStoryResultResponse: value}
}

func (s *SetupStoryStorySetupPostResponse) UnmarshalJSON(data []byte) error {
	valueOrchestratorPipelineCallResult := new(OrchestratorPipelineCallResult)
	if err := json.Unmarshal(data, &valueOrchestratorPipelineCallResult); err == nil {
		s.typeName = "orchestratorPipelineCallResult"
		s.OrchestratorPipelineCallResult = valueOrchestratorPipelineCallResult
		return nil
	}
	valueGetSetupStoryResultResponse := new(GetSetupStoryResultResponse)
	if err := json.Unmarshal(data, &valueGetSetupStoryResultResponse); err == nil {
		s.typeName = "getSetupStoryResultResponse"
		s.GetSetupStoryResultResponse = valueGetSetupStoryResultResponse
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SetupStoryStorySetupPostResponse) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "orchestratorPipelineCallResult":
		return json.Marshal(s.OrchestratorPipelineCallResult)
	case "getSetupStoryResultResponse":
		return json.Marshal(s.GetSetupStoryResultResponse)
	}
}

type SetupStoryStorySetupPostResponseVisitor interface {
	VisitOrchestratorPipelineCallResult(*OrchestratorPipelineCallResult) error
	VisitGetSetupStoryResultResponse(*GetSetupStoryResultResponse) error
}

func (s *SetupStoryStorySetupPostResponse) Accept(visitor SetupStoryStorySetupPostResponseVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "orchestratorPipelineCallResult":
		return visitor.VisitOrchestratorPipelineCallResult(s.OrchestratorPipelineCallResult)
	case "getSetupStoryResultResponse":
		return visitor.VisitGetSetupStoryResultResponse(s.GetSetupStoryResultResponse)
	}
}
