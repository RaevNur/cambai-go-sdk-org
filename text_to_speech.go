// This file was auto-generated by Fern from our API Definition.

package cambai

import (
	json "encoding/json"
	fmt "fmt"
	core "sdk/core"
)

type CreateTtsRequestPayload struct {
	RunID              *int      `json:"-" url:"run_id,omitempty"`
	ProjectName        *string   `json:"project_name,omitempty" url:"project_name,omitempty"`
	ProjectDescription *string   `json:"project_description,omitempty" url:"project_description,omitempty"`
	FolderID           *int      `json:"folder_id,omitempty" url:"folder_id,omitempty"`
	Text               string    `json:"text" url:"text"`
	VoiceID            int       `json:"voice_id" url:"voice_id"`
	Language           Languages `json:"language" url:"language"`
	Gender             *Gender   `json:"gender,omitempty" url:"gender,omitempty"`
	Age                *int      `json:"age,omitempty" url:"age,omitempty"`
}

type GetTtsResultTtsTaskIDGetRequest struct {
	RunID *int `json:"-" url:"run_id,omitempty"`
}

type GetTtsResultDiscordDiscordTtsTaskIDGetRequest struct {
	RunID *int `json:"-" url:"run_id,omitempty"`
}

type GetTtsResultsTtsResultsPostRequest struct {
	Traceparent *string               `json:"-" url:"-"`
	RunID       *int                  `json:"-" url:"run_id,omitempty"`
	Body        *RunIDsRequestPayload `json:"-" url:"-"`
}

func (g *GetTtsResultsTtsResultsPostRequest) UnmarshalJSON(data []byte) error {
	body := new(RunIDsRequestPayload)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	g.Body = body
	return nil
}

func (g *GetTtsResultsTtsResultsPostRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(g.Body)
}

type GetTtsRunInfoTtsResultRunIDGetRequest struct {
	// Output format for the Text To Speech result
	OutputType *string `json:"-" url:"output_type,omitempty"`
}

type CreateStreamTtsRequestPayload struct {
	Text                              string                                    `json:"text" url:"text"`
	Language                          CreateStreamTtsRequestPayloadLanguage     `json:"language,omitempty" url:"language,omitempty"`
	VoiceID                           int                                       `json:"voice_id" url:"voice_id"`
	SpeechModel                       *CreateStreamTtsRequestPayloadSpeechModel `json:"speech_model,omitempty" url:"speech_model,omitempty"`
	UserInstructions                  *string                                   `json:"user_instructions,omitempty" url:"user_instructions,omitempty"`
	EnhanceNamedEntitiesPronunciation *bool                                     `json:"enhance_named_entities_pronunciation,omitempty" url:"enhance_named_entities_pronunciation,omitempty"`
	OutputConfiguration               *StreamTtsOutputConfiguration             `json:"output_configuration,omitempty" url:"output_configuration,omitempty"`
	VoiceSettings                     *StreamTtsVoiceSettings                   `json:"voice_settings,omitempty" url:"voice_settings,omitempty"`
	InferenceOptions                  *StreamTtsInferenceOptions                `json:"inference_options,omitempty" url:"inference_options,omitempty"`
}

type CreateTtsOut struct {
	TaskID string `json:"task_id" url:"task_id"`

	_rawJSON json.RawMessage
}

func (c *CreateTtsOut) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateTtsOut
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateTtsOut(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTtsOut) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type GetTtsResultOutFileURL struct {
	OutputURL string `json:"output_url" url:"output_url"`

	_rawJSON json.RawMessage
}

func (g *GetTtsResultOutFileURL) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTtsResultOutFileURL
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTtsResultOutFileURL(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTtsResultOutFileURL) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type OutputFormat string

const (
	OutputFormatWav      OutputFormat = "wav"
	OutputFormatFlac     OutputFormat = "flac"
	OutputFormatAdts     OutputFormat = "adts"
	OutputFormatMp3      OutputFormat = "mp3"
	OutputFormatPcmS16Le OutputFormat = "pcm_s16le"
	OutputFormatPcmS16Be OutputFormat = "pcm_s16be"
	OutputFormatPcmS32Be OutputFormat = "pcm_s32be"
	OutputFormatPcmS32Le OutputFormat = "pcm_s32le"
	OutputFormatPcmF32Le OutputFormat = "pcm_f32le"
	OutputFormatPcmF32Be OutputFormat = "pcm_f32be"
)

func NewOutputFormatFromString(s string) (OutputFormat, error) {
	switch s {
	case "wav":
		return OutputFormatWav, nil
	case "flac":
		return OutputFormatFlac, nil
	case "adts":
		return OutputFormatAdts, nil
	case "mp3":
		return OutputFormatMp3, nil
	case "pcm_s16le":
		return OutputFormatPcmS16Le, nil
	case "pcm_s16be":
		return OutputFormatPcmS16Be, nil
	case "pcm_s32be":
		return OutputFormatPcmS32Be, nil
	case "pcm_s32le":
		return OutputFormatPcmS32Le, nil
	case "pcm_f32le":
		return OutputFormatPcmF32Le, nil
	case "pcm_f32be":
		return OutputFormatPcmF32Be, nil
	}
	var t OutputFormat
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OutputFormat) Ptr() *OutputFormat {
	return &o
}

// Advanced options for controlling the TTS inference process.
//
// These options are only supported for the MARS-8 family of speech models.
//
// Attributes:
//
//	stability: A value between 0.0 and 1.0 that controls the stability of
//	    the output audio.
//	temperature: A value between 0.01 and 4.0 that controls the randomness
//	    of the output. Higher values mean more randomness.
//	inference_steps: The number of steps for the diffusion model. A value
//	    between 1 and 1000.
//	speaker_similarity: A value between 0.0 and 1.0 that controls how
//	    similar the output should be to the reference speaker.
type StreamTtsInferenceOptions struct {
	Stability         *float64 `json:"stability,omitempty" url:"stability,omitempty"`
	Temperature       *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	InferenceSteps    *int     `json:"inference_steps,omitempty" url:"inference_steps,omitempty"`
	SpeakerSimilarity *float64 `json:"speaker_similarity,omitempty" url:"speaker_similarity,omitempty"`

	_rawJSON json.RawMessage
}

func (s *StreamTtsInferenceOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler StreamTtsInferenceOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StreamTtsInferenceOptions(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StreamTtsInferenceOptions) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for the output audio of Streaming TTS.
//
// Attributes:
//
//	format: The format of the output audio. Defaults to MP3.
//	duration: The desired duration of the output audio in seconds. If not
//	    provided, it will be determined automatically.
//	apply_enhancement: Whether to apply audio enhancement to the output.
//	    Defaults to True.
type StreamTtsOutputConfiguration struct {
	Format           *OutputFormat `json:"format,omitempty" url:"format,omitempty"`
	Duration         *float64      `json:"duration,omitempty" url:"duration,omitempty"`
	ApplyEnhancement *bool         `json:"apply_enhancement,omitempty" url:"apply_enhancement,omitempty"`

	_rawJSON json.RawMessage
}

func (s *StreamTtsOutputConfiguration) UnmarshalJSON(data []byte) error {
	type unmarshaler StreamTtsOutputConfiguration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StreamTtsOutputConfiguration(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StreamTtsOutputConfiguration) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Advanced settings for voice customization.
//
// Attributes:
//
//	enhance_reference_audio_quality: Whether to enhance the quality of the
//	    reference audio before cloning. Defaults to False.
type StreamTtsVoiceSettings struct {
	EnhanceReferenceAudioQuality *bool `json:"enhance_reference_audio_quality,omitempty" url:"enhance_reference_audio_quality,omitempty"`
	MaintainSourceAccent         *bool `json:"maintain_source_accent,omitempty" url:"maintain_source_accent,omitempty"`

	_rawJSON json.RawMessage
}

func (s *StreamTtsVoiceSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler StreamTtsVoiceSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StreamTtsVoiceSettings(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StreamTtsVoiceSettings) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type CreateStreamTtsRequestPayloadLanguage string

const (
	CreateStreamTtsRequestPayloadLanguageArKw CreateStreamTtsRequestPayloadLanguage = "ar-kw"
	CreateStreamTtsRequestPayloadLanguageDeCh CreateStreamTtsRequestPayloadLanguage = "de-ch"
	CreateStreamTtsRequestPayloadLanguageKoKr CreateStreamTtsRequestPayloadLanguage = "ko-kr"
	CreateStreamTtsRequestPayloadLanguageThTh CreateStreamTtsRequestPayloadLanguage = "th-th"
	CreateStreamTtsRequestPayloadLanguageMlIn CreateStreamTtsRequestPayloadLanguage = "ml-in"
	CreateStreamTtsRequestPayloadLanguagePtPt CreateStreamTtsRequestPayloadLanguage = "pt-pt"
	CreateStreamTtsRequestPayloadLanguageKnIn CreateStreamTtsRequestPayloadLanguage = "kn-in"
	CreateStreamTtsRequestPayloadLanguageFiFi CreateStreamTtsRequestPayloadLanguage = "fi-fi"
	CreateStreamTtsRequestPayloadLanguageEsMx CreateStreamTtsRequestPayloadLanguage = "es-mx"
	CreateStreamTtsRequestPayloadLanguageFrCa CreateStreamTtsRequestPayloadLanguage = "fr-ca"
	CreateStreamTtsRequestPayloadLanguageCsCz CreateStreamTtsRequestPayloadLanguage = "cs-cz"
	CreateStreamTtsRequestPayloadLanguagePtBr CreateStreamTtsRequestPayloadLanguage = "pt-br"
	CreateStreamTtsRequestPayloadLanguageHiIn CreateStreamTtsRequestPayloadLanguage = "hi-in"
	CreateStreamTtsRequestPayloadLanguageArSy CreateStreamTtsRequestPayloadLanguage = "ar-sy"
	CreateStreamTtsRequestPayloadLanguageEsUs CreateStreamTtsRequestPayloadLanguage = "es-us"
	CreateStreamTtsRequestPayloadLanguageBnBd CreateStreamTtsRequestPayloadLanguage = "bn-bd"
	CreateStreamTtsRequestPayloadLanguageJaJp CreateStreamTtsRequestPayloadLanguage = "ja-jp"
	CreateStreamTtsRequestPayloadLanguageMrIn CreateStreamTtsRequestPayloadLanguage = "mr-in"
	CreateStreamTtsRequestPayloadLanguageArMa CreateStreamTtsRequestPayloadLanguage = "ar-ma"
	CreateStreamTtsRequestPayloadLanguageEsEs CreateStreamTtsRequestPayloadLanguage = "es-es"
	CreateStreamTtsRequestPayloadLanguageEnUs CreateStreamTtsRequestPayloadLanguage = "en-us"
	CreateStreamTtsRequestPayloadLanguageZhCn CreateStreamTtsRequestPayloadLanguage = "zh-cn"
	CreateStreamTtsRequestPayloadLanguageElGr CreateStreamTtsRequestPayloadLanguage = "el-gr"
	CreateStreamTtsRequestPayloadLanguagePlPl CreateStreamTtsRequestPayloadLanguage = "pl-pl"
	CreateStreamTtsRequestPayloadLanguageArOm CreateStreamTtsRequestPayloadLanguage = "ar-om"
	CreateStreamTtsRequestPayloadLanguageFrCh CreateStreamTtsRequestPayloadLanguage = "fr-ch"
	CreateStreamTtsRequestPayloadLanguageEnUk CreateStreamTtsRequestPayloadLanguage = "en-uk"
	CreateStreamTtsRequestPayloadLanguageEnAu CreateStreamTtsRequestPayloadLanguage = "en-au"
	CreateStreamTtsRequestPayloadLanguageArJo CreateStreamTtsRequestPayloadLanguage = "ar-jo"
	CreateStreamTtsRequestPayloadLanguageArAe CreateStreamTtsRequestPayloadLanguage = "ar-ae"
	CreateStreamTtsRequestPayloadLanguageTrTr CreateStreamTtsRequestPayloadLanguage = "tr-tr"
	CreateStreamTtsRequestPayloadLanguageArLy CreateStreamTtsRequestPayloadLanguage = "ar-ly"
	CreateStreamTtsRequestPayloadLanguageRuRu CreateStreamTtsRequestPayloadLanguage = "ru-ru"
	CreateStreamTtsRequestPayloadLanguageEnIn CreateStreamTtsRequestPayloadLanguage = "en-in"
	CreateStreamTtsRequestPayloadLanguageArYe CreateStreamTtsRequestPayloadLanguage = "ar-ye"
	CreateStreamTtsRequestPayloadLanguageArEg CreateStreamTtsRequestPayloadLanguage = "ar-eg"
	CreateStreamTtsRequestPayloadLanguageFrBe CreateStreamTtsRequestPayloadLanguage = "fr-be"
	CreateStreamTtsRequestPayloadLanguageTaIn CreateStreamTtsRequestPayloadLanguage = "ta-in"
	CreateStreamTtsRequestPayloadLanguageZhTw CreateStreamTtsRequestPayloadLanguage = "zh-tw"
	CreateStreamTtsRequestPayloadLanguageViVn CreateStreamTtsRequestPayloadLanguage = "vi-vn"
	CreateStreamTtsRequestPayloadLanguageBnIn CreateStreamTtsRequestPayloadLanguage = "bn-in"
	CreateStreamTtsRequestPayloadLanguageArSa CreateStreamTtsRequestPayloadLanguage = "ar-sa"
	CreateStreamTtsRequestPayloadLanguageDeAt CreateStreamTtsRequestPayloadLanguage = "de-at"
	CreateStreamTtsRequestPayloadLanguagePaIn CreateStreamTtsRequestPayloadLanguage = "pa-in"
	CreateStreamTtsRequestPayloadLanguageItIt CreateStreamTtsRequestPayloadLanguage = "it-it"
	CreateStreamTtsRequestPayloadLanguageNlNl CreateStreamTtsRequestPayloadLanguage = "nl-nl"
	CreateStreamTtsRequestPayloadLanguageArBh CreateStreamTtsRequestPayloadLanguage = "ar-bh"
	CreateStreamTtsRequestPayloadLanguageFrFr CreateStreamTtsRequestPayloadLanguage = "fr-fr"
	CreateStreamTtsRequestPayloadLanguageArQa CreateStreamTtsRequestPayloadLanguage = "ar-qa"
	CreateStreamTtsRequestPayloadLanguageUkUa CreateStreamTtsRequestPayloadLanguage = "uk-ua"
	CreateStreamTtsRequestPayloadLanguageArTn CreateStreamTtsRequestPayloadLanguage = "ar-tn"
	CreateStreamTtsRequestPayloadLanguageDeDe CreateStreamTtsRequestPayloadLanguage = "de-de"
	CreateStreamTtsRequestPayloadLanguageArXa CreateStreamTtsRequestPayloadLanguage = "ar-xa"
	CreateStreamTtsRequestPayloadLanguageArLb CreateStreamTtsRequestPayloadLanguage = "ar-lb"
	CreateStreamTtsRequestPayloadLanguageZhHk CreateStreamTtsRequestPayloadLanguage = "zh-hk"
	CreateStreamTtsRequestPayloadLanguageRoRo CreateStreamTtsRequestPayloadLanguage = "ro-ro"
	CreateStreamTtsRequestPayloadLanguageAsIn CreateStreamTtsRequestPayloadLanguage = "as-in"
	CreateStreamTtsRequestPayloadLanguageArIq CreateStreamTtsRequestPayloadLanguage = "ar-iq"
	CreateStreamTtsRequestPayloadLanguageNlBe CreateStreamTtsRequestPayloadLanguage = "nl-be"
	CreateStreamTtsRequestPayloadLanguageTeIn CreateStreamTtsRequestPayloadLanguage = "te-in"
	CreateStreamTtsRequestPayloadLanguageIdId CreateStreamTtsRequestPayloadLanguage = "id-id"
	CreateStreamTtsRequestPayloadLanguageArDz CreateStreamTtsRequestPayloadLanguage = "ar-dz"
)

func NewCreateStreamTtsRequestPayloadLanguageFromString(s string) (CreateStreamTtsRequestPayloadLanguage, error) {
	switch s {
	case "ar-kw":
		return CreateStreamTtsRequestPayloadLanguageArKw, nil
	case "de-ch":
		return CreateStreamTtsRequestPayloadLanguageDeCh, nil
	case "ko-kr":
		return CreateStreamTtsRequestPayloadLanguageKoKr, nil
	case "th-th":
		return CreateStreamTtsRequestPayloadLanguageThTh, nil
	case "ml-in":
		return CreateStreamTtsRequestPayloadLanguageMlIn, nil
	case "pt-pt":
		return CreateStreamTtsRequestPayloadLanguagePtPt, nil
	case "kn-in":
		return CreateStreamTtsRequestPayloadLanguageKnIn, nil
	case "fi-fi":
		return CreateStreamTtsRequestPayloadLanguageFiFi, nil
	case "es-mx":
		return CreateStreamTtsRequestPayloadLanguageEsMx, nil
	case "fr-ca":
		return CreateStreamTtsRequestPayloadLanguageFrCa, nil
	case "cs-cz":
		return CreateStreamTtsRequestPayloadLanguageCsCz, nil
	case "pt-br":
		return CreateStreamTtsRequestPayloadLanguagePtBr, nil
	case "hi-in":
		return CreateStreamTtsRequestPayloadLanguageHiIn, nil
	case "ar-sy":
		return CreateStreamTtsRequestPayloadLanguageArSy, nil
	case "es-us":
		return CreateStreamTtsRequestPayloadLanguageEsUs, nil
	case "bn-bd":
		return CreateStreamTtsRequestPayloadLanguageBnBd, nil
	case "ja-jp":
		return CreateStreamTtsRequestPayloadLanguageJaJp, nil
	case "mr-in":
		return CreateStreamTtsRequestPayloadLanguageMrIn, nil
	case "ar-ma":
		return CreateStreamTtsRequestPayloadLanguageArMa, nil
	case "es-es":
		return CreateStreamTtsRequestPayloadLanguageEsEs, nil
	case "en-us":
		return CreateStreamTtsRequestPayloadLanguageEnUs, nil
	case "zh-cn":
		return CreateStreamTtsRequestPayloadLanguageZhCn, nil
	case "el-gr":
		return CreateStreamTtsRequestPayloadLanguageElGr, nil
	case "pl-pl":
		return CreateStreamTtsRequestPayloadLanguagePlPl, nil
	case "ar-om":
		return CreateStreamTtsRequestPayloadLanguageArOm, nil
	case "fr-ch":
		return CreateStreamTtsRequestPayloadLanguageFrCh, nil
	case "en-uk":
		return CreateStreamTtsRequestPayloadLanguageEnUk, nil
	case "en-au":
		return CreateStreamTtsRequestPayloadLanguageEnAu, nil
	case "ar-jo":
		return CreateStreamTtsRequestPayloadLanguageArJo, nil
	case "ar-ae":
		return CreateStreamTtsRequestPayloadLanguageArAe, nil
	case "tr-tr":
		return CreateStreamTtsRequestPayloadLanguageTrTr, nil
	case "ar-ly":
		return CreateStreamTtsRequestPayloadLanguageArLy, nil
	case "ru-ru":
		return CreateStreamTtsRequestPayloadLanguageRuRu, nil
	case "en-in":
		return CreateStreamTtsRequestPayloadLanguageEnIn, nil
	case "ar-ye":
		return CreateStreamTtsRequestPayloadLanguageArYe, nil
	case "ar-eg":
		return CreateStreamTtsRequestPayloadLanguageArEg, nil
	case "fr-be":
		return CreateStreamTtsRequestPayloadLanguageFrBe, nil
	case "ta-in":
		return CreateStreamTtsRequestPayloadLanguageTaIn, nil
	case "zh-tw":
		return CreateStreamTtsRequestPayloadLanguageZhTw, nil
	case "vi-vn":
		return CreateStreamTtsRequestPayloadLanguageViVn, nil
	case "bn-in":
		return CreateStreamTtsRequestPayloadLanguageBnIn, nil
	case "ar-sa":
		return CreateStreamTtsRequestPayloadLanguageArSa, nil
	case "de-at":
		return CreateStreamTtsRequestPayloadLanguageDeAt, nil
	case "pa-in":
		return CreateStreamTtsRequestPayloadLanguagePaIn, nil
	case "it-it":
		return CreateStreamTtsRequestPayloadLanguageItIt, nil
	case "nl-nl":
		return CreateStreamTtsRequestPayloadLanguageNlNl, nil
	case "ar-bh":
		return CreateStreamTtsRequestPayloadLanguageArBh, nil
	case "fr-fr":
		return CreateStreamTtsRequestPayloadLanguageFrFr, nil
	case "ar-qa":
		return CreateStreamTtsRequestPayloadLanguageArQa, nil
	case "uk-ua":
		return CreateStreamTtsRequestPayloadLanguageUkUa, nil
	case "ar-tn":
		return CreateStreamTtsRequestPayloadLanguageArTn, nil
	case "de-de":
		return CreateStreamTtsRequestPayloadLanguageDeDe, nil
	case "ar-xa":
		return CreateStreamTtsRequestPayloadLanguageArXa, nil
	case "ar-lb":
		return CreateStreamTtsRequestPayloadLanguageArLb, nil
	case "zh-hk":
		return CreateStreamTtsRequestPayloadLanguageZhHk, nil
	case "ro-ro":
		return CreateStreamTtsRequestPayloadLanguageRoRo, nil
	case "as-in":
		return CreateStreamTtsRequestPayloadLanguageAsIn, nil
	case "ar-iq":
		return CreateStreamTtsRequestPayloadLanguageArIq, nil
	case "nl-be":
		return CreateStreamTtsRequestPayloadLanguageNlBe, nil
	case "te-in":
		return CreateStreamTtsRequestPayloadLanguageTeIn, nil
	case "id-id":
		return CreateStreamTtsRequestPayloadLanguageIdId, nil
	case "ar-dz":
		return CreateStreamTtsRequestPayloadLanguageArDz, nil
	}
	var t CreateStreamTtsRequestPayloadLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateStreamTtsRequestPayloadLanguage) Ptr() *CreateStreamTtsRequestPayloadLanguage {
	return &c
}

type CreateStreamTtsRequestPayloadSpeechModel string

const (
	CreateStreamTtsRequestPayloadSpeechModelAuto          CreateStreamTtsRequestPayloadSpeechModel = "auto"
	CreateStreamTtsRequestPayloadSpeechModelMars8         CreateStreamTtsRequestPayloadSpeechModel = "mars-8"
	CreateStreamTtsRequestPayloadSpeechModelMars8Flash    CreateStreamTtsRequestPayloadSpeechModel = "mars-8-flash"
	CreateStreamTtsRequestPayloadSpeechModelMars8Instruct CreateStreamTtsRequestPayloadSpeechModel = "mars-8-instruct"
	CreateStreamTtsRequestPayloadSpeechModelMars7         CreateStreamTtsRequestPayloadSpeechModel = "mars-7"
	CreateStreamTtsRequestPayloadSpeechModelMars6         CreateStreamTtsRequestPayloadSpeechModel = "mars-6"
)

func NewCreateStreamTtsRequestPayloadSpeechModelFromString(s string) (CreateStreamTtsRequestPayloadSpeechModel, error) {
	switch s {
	case "auto":
		return CreateStreamTtsRequestPayloadSpeechModelAuto, nil
	case "mars-8":
		return CreateStreamTtsRequestPayloadSpeechModelMars8, nil
	case "mars-8-flash":
		return CreateStreamTtsRequestPayloadSpeechModelMars8Flash, nil
	case "mars-8-instruct":
		return CreateStreamTtsRequestPayloadSpeechModelMars8Instruct, nil
	case "mars-7":
		return CreateStreamTtsRequestPayloadSpeechModelMars7, nil
	case "mars-6":
		return CreateStreamTtsRequestPayloadSpeechModelMars6, nil
	}
	var t CreateStreamTtsRequestPayloadSpeechModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateStreamTtsRequestPayloadSpeechModel) Ptr() *CreateStreamTtsRequestPayloadSpeechModel {
	return &c
}

type GetTtsResultsTtsResultsPostResponseValue struct {
	typeName               string
	String                 string
	GetTtsResultOutFileURL *GetTtsResultOutFileURL
}

func NewGetTtsResultsTtsResultsPostResponseValueFromString(value string) *GetTtsResultsTtsResultsPostResponseValue {
	return &GetTtsResultsTtsResultsPostResponseValue{typeName: "string", String: value}
}

func NewGetTtsResultsTtsResultsPostResponseValueFromGetTtsResultOutFileURL(value *GetTtsResultOutFileURL) *GetTtsResultsTtsResultsPostResponseValue {
	return &GetTtsResultsTtsResultsPostResponseValue{typeName: "getTtsResultOutFileURL", GetTtsResultOutFileURL: value}
}

func (g *GetTtsResultsTtsResultsPostResponseValue) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	valueGetTtsResultOutFileURL := new(GetTtsResultOutFileURL)
	if err := json.Unmarshal(data, &valueGetTtsResultOutFileURL); err == nil {
		g.typeName = "getTtsResultOutFileURL"
		g.GetTtsResultOutFileURL = valueGetTtsResultOutFileURL
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetTtsResultsTtsResultsPostResponseValue) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "string":
		return json.Marshal(g.String)
	case "getTtsResultOutFileURL":
		return json.Marshal(g.GetTtsResultOutFileURL)
	}
}

type GetTtsResultsTtsResultsPostResponseValueVisitor interface {
	VisitString(string) error
	VisitGetTtsResultOutFileURL(*GetTtsResultOutFileURL) error
}

func (g *GetTtsResultsTtsResultsPostResponseValue) Accept(visitor GetTtsResultsTtsResultsPostResponseValueVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "string":
		return visitor.VisitString(g.String)
	case "getTtsResultOutFileURL":
		return visitor.VisitGetTtsResultOutFileURL(g.GetTtsResultOutFileURL)
	}
}

type GetTtsRunInfoTtsResultRunIDGetResponse struct {
	typeName               string
	String                 string
	GetTtsResultOutFileURL *GetTtsResultOutFileURL
}

func NewGetTtsRunInfoTtsResultRunIDGetResponseFromString(value string) *GetTtsRunInfoTtsResultRunIDGetResponse {
	return &GetTtsRunInfoTtsResultRunIDGetResponse{typeName: "string", String: value}
}

func NewGetTtsRunInfoTtsResultRunIDGetResponseFromGetTtsResultOutFileURL(value *GetTtsResultOutFileURL) *GetTtsRunInfoTtsResultRunIDGetResponse {
	return &GetTtsRunInfoTtsResultRunIDGetResponse{typeName: "getTtsResultOutFileURL", GetTtsResultOutFileURL: value}
}

func (g *GetTtsRunInfoTtsResultRunIDGetResponse) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	valueGetTtsResultOutFileURL := new(GetTtsResultOutFileURL)
	if err := json.Unmarshal(data, &valueGetTtsResultOutFileURL); err == nil {
		g.typeName = "getTtsResultOutFileURL"
		g.GetTtsResultOutFileURL = valueGetTtsResultOutFileURL
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetTtsRunInfoTtsResultRunIDGetResponse) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "string":
		return json.Marshal(g.String)
	case "getTtsResultOutFileURL":
		return json.Marshal(g.GetTtsResultOutFileURL)
	}
}

type GetTtsRunInfoTtsResultRunIDGetResponseVisitor interface {
	VisitString(string) error
	VisitGetTtsResultOutFileURL(*GetTtsResultOutFileURL) error
}

func (g *GetTtsRunInfoTtsResultRunIDGetResponse) Accept(visitor GetTtsRunInfoTtsResultRunIDGetResponseVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "string":
		return visitor.VisitString(g.String)
	case "getTtsResultOutFileURL":
		return visitor.VisitGetTtsResultOutFileURL(g.GetTtsResultOutFileURL)
	}
}
