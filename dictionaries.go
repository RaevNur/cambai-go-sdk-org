// This file was auto-generated by Fern from our API Definition.

package cambai

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/camb-ai/cambai-go-sdk/core"
	time "time"
)

type AddDictionaryTermPayload struct {
	RunID        *int                    `json:"-" url:"run_id,omitempty"`
	Translations []*TermTranslationInput `json:"translations,omitempty" url:"translations,omitempty"`
}

type BodyCreateDictionaryFromFileDictionariesCreateFromFilePost struct {
	RunID *int `json:"-" url:"run_id,omitempty"`
	// The name of the dictonary to be created. This is mainly used for organizational purposes.
	DictionaryName string `json:"dictionary_name" url:"dictionary_name"`
	// The description of the dictionary to be created. This is an optional field that is used to help you provide some info about your dictionaries for better organization.
	DictionaryDescription *string `json:"dictionary_description,omitempty" url:"dictionary_description,omitempty"`
}

type DeleteDictionaryDictionariesDictionaryIDDeleteRequest struct {
	RunID *int `json:"-" url:"run_id,omitempty"`
}

type DeleteDictionaryTermDictionariesTermDictionaryIDTermIDDeleteRequest struct {
	RunID *int `json:"-" url:"run_id,omitempty"`
}

type GetDictionariesDictionariesGetRequest struct {
	RunID *int `json:"-" url:"run_id,omitempty"`
}

type GetDictionaryDetailsDictionariesDictionaryIDFullDetailsGetRequest struct {
	// Limit how many terms are returned when fetching the dictionary details.
	Limit      *int    `json:"-" url:"limit,omitempty"`
	SearchTerm *string `json:"-" url:"search_term,omitempty"`
	RunID      *int    `json:"-" url:"run_id,omitempty"`
}

type GetDictionaryInfoDictionariesDictionaryIDGetRequest struct {
	RunID *int `json:"-" url:"run_id,omitempty"`
}

type DictionaryTerm struct {
	ID               int                      `json:"id" url:"id"`
	TermTranslations []*TermTranslationOutput `json:"term_translations,omitempty" url:"term_translations,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DictionaryTerm) UnmarshalJSON(data []byte) error {
	type unmarshaler DictionaryTerm
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DictionaryTerm(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DictionaryTerm) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DictionaryWithTerms struct {
	ID              int               `json:"id" url:"id"`
	Name            string            `json:"name" url:"name"`
	Description     *string           `json:"description,omitempty" url:"description,omitempty"`
	CreatedAt       *time.Time        `json:"created_at,omitempty" url:"created_at,omitempty"`
	LastEditedAt    *time.Time        `json:"last_edited_at,omitempty" url:"last_edited_at,omitempty"`
	DictionaryTerms []*DictionaryTerm `json:"dictionary_terms,omitempty" url:"dictionary_terms,omitempty"`
	Languages       []Languages       `json:"languages,omitempty" url:"languages,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DictionaryWithTerms) UnmarshalJSON(data []byte) error {
	type embed DictionaryWithTerms
	var unmarshaler = struct {
		embed
		CreatedAt    *core.DateTime `json:"created_at,omitempty"`
		LastEditedAt *core.DateTime `json:"last_edited_at,omitempty"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DictionaryWithTerms(unmarshaler.embed)
	d.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	d.LastEditedAt = unmarshaler.LastEditedAt.TimePtr()
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DictionaryWithTerms) MarshalJSON() ([]byte, error) {
	type embed DictionaryWithTerms
	var marshaler = struct {
		embed
		CreatedAt    *core.DateTime `json:"created_at,omitempty"`
		LastEditedAt *core.DateTime `json:"last_edited_at,omitempty"`
	}{
		embed:        embed(*d),
		CreatedAt:    core.NewOptionalDateTime(d.CreatedAt),
		LastEditedAt: core.NewOptionalDateTime(d.LastEditedAt),
	}
	return json.Marshal(marshaler)
}

func (d *DictionaryWithTerms) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type TermTranslationInput struct {
	Translation string    `json:"translation" url:"translation"`
	Language    Languages `json:"language" url:"language"`

	_rawJSON json.RawMessage
}

func (t *TermTranslationInput) UnmarshalJSON(data []byte) error {
	type unmarshaler TermTranslationInput
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TermTranslationInput(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TermTranslationInput) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TermTranslationOutput struct {
	Language int    `json:"language" url:"language"`
	TermText string `json:"term_text" url:"term_text"`

	_rawJSON json.RawMessage
}

func (t *TermTranslationOutput) UnmarshalJSON(data []byte) error {
	type unmarshaler TermTranslationOutput
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TermTranslationOutput(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TermTranslationOutput) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type UpdateTermTranslationsPayload struct {
	RunID        *int                    `json:"-" url:"run_id,omitempty"`
	Translations []*TermTranslationInput `json:"translations,omitempty" url:"translations,omitempty"`
}
