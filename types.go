// This file was auto-generated by Fern from our API Definition.

package cambai

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/camb-ai/cambai-go-sdk/core"
	time "time"
)

type AudioStream struct {
	Index          int                    `json:"index" url:"index"`
	CodecName      string                 `json:"codec_name" url:"codec_name"`
	CodecLongName  string                 `json:"codec_long_name" url:"codec_long_name"`
	CodecTagString *string                `json:"codec_tag_string,omitempty" url:"codec_tag_string,omitempty"`
	CodecTag       *string                `json:"codec_tag,omitempty" url:"codec_tag,omitempty"`
	Profile        *string                `json:"profile,omitempty" url:"profile,omitempty"`
	SampleFmt      string                 `json:"sample_fmt" url:"sample_fmt"`
	SampleRate     int                    `json:"sample_rate" url:"sample_rate"`
	Channels       int                    `json:"channels" url:"channels"`
	ChannelLayout  *string                `json:"channel_layout,omitempty" url:"channel_layout,omitempty"`
	ID             *string                `json:"id,omitempty" url:"id,omitempty"`
	BitRate        *int                   `json:"bit_rate,omitempty" url:"bit_rate,omitempty"`
	Tags           map[string]interface{} `json:"tags,omitempty" url:"tags,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AudioStream) UnmarshalJSON(data []byte) error {
	type unmarshaler AudioStream
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AudioStream(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AudioStream) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ConfigStream struct {
	Pipeline *ConfigStreamPipeline `json:"pipeline,omitempty" url:"pipeline,omitempty"`
	Mixing   *OverdubConfig        `json:"mixing,omitempty" url:"mixing,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConfigStream) UnmarshalJSON(data []byte) error {
	type unmarshaler ConfigStream
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConfigStream(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConfigStream) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConfigStreamPipeline struct {
	Demixing     *DemixingOption     `json:"demixing,omitempty" url:"demixing,omitempty"`
	Segmenting   *SegmentingOption   `json:"segmenting,omitempty" url:"segmenting,omitempty"`
	Transcribing *TranscribingOption `json:"transcribing,omitempty" url:"transcribing,omitempty"`
	Translating  *TranslatingOption  `json:"translating,omitempty" url:"translating,omitempty"`
	Revoicing    *RevoicingOption    `json:"revoicing,omitempty" url:"revoicing,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConfigStreamPipeline) UnmarshalJSON(data []byte) error {
	type unmarshaler ConfigStreamPipeline
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConfigStreamPipeline(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConfigStreamPipeline) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateStreamOut struct {
	StreamID              int                      `json:"stream_id" url:"stream_id"`
	StreamURLForLanguages []*StreamURLForLanguages `json:"stream_url_for_languages,omitempty" url:"stream_url_for_languages,omitempty"`
	TaskID                string                   `json:"task_id" url:"task_id"`

	_rawJSON json.RawMessage
}

func (c *CreateStreamOut) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateStreamOut
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateStreamOut(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateStreamOut) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateStreamRequestPayload struct {
	// The name of the stream.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The description of the stream.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The initial delay in seconds before starting the stream creation process.
	InitialDelay *int `json:"initial_delay,omitempty" url:"initial_delay,omitempty"`
	// The maximum duration in minutes for the stream creation process before timing out.
	TimeoutInMins *int `json:"timeout_in_mins,omitempty" url:"timeout_in_mins,omitempty"`
	// List of voice identifiers to be used in the stream.
	Voices []int `json:"voices,omitempty" url:"voices,omitempty"`
	// List of dictionary identifiers to be used in the stream.
	Dictionaries []int `json:"dictionaries,omitempty" url:"dictionaries,omitempty"`
	// The shared configuration for the streaming pipeline.
	Config *ConfigStream `json:"config,omitempty" url:"config,omitempty"`
	// The source stream configuration details.
	SourceStream *SourceStream `json:"source_stream,omitempty" url:"source_stream,omitempty"`
	// List of target stream configurations.
	TargetStreams []*TargetStream `json:"target_streams,omitempty" url:"target_streams,omitempty"`
	StartTime     *time.Time      `json:"start_time,omitempty" url:"start_time,omitempty"`
	EndTime       *time.Time      `json:"end_time,omitempty" url:"end_time,omitempty"`
	Timezone      *string         `json:"timezone,omitempty" url:"timezone,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreateStreamRequestPayload) UnmarshalJSON(data []byte) error {
	type embed CreateStreamRequestPayload
	var unmarshaler = struct {
		embed
		StartTime *core.DateTime `json:"start_time,omitempty"`
		EndTime   *core.DateTime `json:"end_time,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateStreamRequestPayload(unmarshaler.embed)
	c.StartTime = unmarshaler.StartTime.TimePtr()
	c.EndTime = unmarshaler.EndTime.TimePtr()
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateStreamRequestPayload) MarshalJSON() ([]byte, error) {
	type embed CreateStreamRequestPayload
	var marshaler = struct {
		embed
		StartTime *core.DateTime `json:"start_time,omitempty"`
		EndTime   *core.DateTime `json:"end_time,omitempty"`
	}{
		embed:     embed(*c),
		StartTime: core.NewOptionalDateTime(c.StartTime),
		EndTime:   core.NewOptionalDateTime(c.EndTime),
	}
	return json.Marshal(marshaler)
}

func (c *CreateStreamRequestPayload) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DataStream struct {
	Index          int     `json:"index" url:"index"`
	CodecName      *string `json:"codec_name,omitempty" url:"codec_name,omitempty"`
	CodecLongName  *string `json:"codec_long_name,omitempty" url:"codec_long_name,omitempty"`
	CodecTagString *string `json:"codec_tag_string,omitempty" url:"codec_tag_string,omitempty"`
	CodecTag       *string `json:"codec_tag,omitempty" url:"codec_tag,omitempty"`
	ID             *string `json:"id,omitempty" url:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DataStream) UnmarshalJSON(data []byte) error {
	type unmarshaler DataStream
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DataStream(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DataStream) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DemixingOption string

const (
	DemixingOptionNone              DemixingOption = "none"
	DemixingOptionPickLeftChannel   DemixingOption = "pick_left_channel"
	DemixingOptionPickRightChannel  DemixingOption = "pick_right_channel"
	DemixingOptionPickCenterChannel DemixingOption = "pick_center_channel"
	DemixingOptionBestModel         DemixingOption = "best_model"
	DemixingOptionFastModel         DemixingOption = "fast_model"
)

func NewDemixingOptionFromString(s string) (DemixingOption, error) {
	switch s {
	case "none":
		return DemixingOptionNone, nil
	case "pick_left_channel":
		return DemixingOptionPickLeftChannel, nil
	case "pick_right_channel":
		return DemixingOptionPickRightChannel, nil
	case "pick_center_channel":
		return DemixingOptionPickCenterChannel, nil
	case "best_model":
		return DemixingOptionBestModel, nil
	case "fast_model":
		return DemixingOptionFastModel, nil
	}
	var t DemixingOption
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DemixingOption) Ptr() *DemixingOption {
	return &d
}

type ExceptionReasons string

const (
	ExceptionReasonsHarmfulContentDetected       ExceptionReasons = "HARMFUL_CONTENT_DETECTED"
	ExceptionReasonsVoiceConversionError         ExceptionReasons = "VOICE_CONVERSION_ERROR"
	ExceptionReasonsProcessingError              ExceptionReasons = "PROCESSING_ERROR"
	ExceptionReasonsSourceTooLong                ExceptionReasons = "SOURCE_TOO_LONG"
	ExceptionReasonsSourceTooLarge               ExceptionReasons = "SOURCE_TOO_LARGE"
	ExceptionReasonsSourceTypeNotSupported       ExceptionReasons = "SOURCE_TYPE_NOT_SUPPORTED"
	ExceptionReasonsErrorDownloadingSource       ExceptionReasons = "ERROR_DOWNLOADING_SOURCE"
	ExceptionReasonsTooManyGdriveRequests        ExceptionReasons = "TOO_MANY_GDRIVE_REQUESTS"
	ExceptionReasonsSourceBlockedInRegion        ExceptionReasons = "SOURCE_BLOCKED_IN_REGION"
	ExceptionReasonsSourceIsAgeRestricted        ExceptionReasons = "SOURCE_IS_AGE_RESTRICTED"
	ExceptionReasonsSourceNotFound               ExceptionReasons = "SOURCE_NOT_FOUND"
	ExceptionReasonsMismatchedSourceCodec        ExceptionReasons = "MISMATCHED_SOURCE_CODEC"
	ExceptionReasonsContentDoesNotMatchExtension ExceptionReasons = "CONTENT_DOES_NOT_MATCH_EXTENSION"
	ExceptionReasonsInvalidSourceData            ExceptionReasons = "INVALID_SOURCE_DATA"
	ExceptionReasonsVideoDoesNotHaveAudioStreams ExceptionReasons = "VIDEO_DOES_NOT_HAVE_AUDIO_STREAMS"
	ExceptionReasonsMasteringOutOfRange          ExceptionReasons = "MASTERING_OUT_OF_RANGE"
	ExceptionReasonsInvalidAudioTracksSelection  ExceptionReasons = "INVALID_AUDIO_TRACKS_SELECTION"
	ExceptionReasonsPaymentRequired              ExceptionReasons = "PAYMENT_REQUIRED"
	ExceptionReasonsForbidden                    ExceptionReasons = "FORBIDDEN"
	ExceptionReasonsInternalError                ExceptionReasons = "INTERNAL_ERROR"
	ExceptionReasonsNone                         ExceptionReasons = "NONE"
)

func NewExceptionReasonsFromString(s string) (ExceptionReasons, error) {
	switch s {
	case "HARMFUL_CONTENT_DETECTED":
		return ExceptionReasonsHarmfulContentDetected, nil
	case "VOICE_CONVERSION_ERROR":
		return ExceptionReasonsVoiceConversionError, nil
	case "PROCESSING_ERROR":
		return ExceptionReasonsProcessingError, nil
	case "SOURCE_TOO_LONG":
		return ExceptionReasonsSourceTooLong, nil
	case "SOURCE_TOO_LARGE":
		return ExceptionReasonsSourceTooLarge, nil
	case "SOURCE_TYPE_NOT_SUPPORTED":
		return ExceptionReasonsSourceTypeNotSupported, nil
	case "ERROR_DOWNLOADING_SOURCE":
		return ExceptionReasonsErrorDownloadingSource, nil
	case "TOO_MANY_GDRIVE_REQUESTS":
		return ExceptionReasonsTooManyGdriveRequests, nil
	case "SOURCE_BLOCKED_IN_REGION":
		return ExceptionReasonsSourceBlockedInRegion, nil
	case "SOURCE_IS_AGE_RESTRICTED":
		return ExceptionReasonsSourceIsAgeRestricted, nil
	case "SOURCE_NOT_FOUND":
		return ExceptionReasonsSourceNotFound, nil
	case "MISMATCHED_SOURCE_CODEC":
		return ExceptionReasonsMismatchedSourceCodec, nil
	case "CONTENT_DOES_NOT_MATCH_EXTENSION":
		return ExceptionReasonsContentDoesNotMatchExtension, nil
	case "INVALID_SOURCE_DATA":
		return ExceptionReasonsInvalidSourceData, nil
	case "VIDEO_DOES_NOT_HAVE_AUDIO_STREAMS":
		return ExceptionReasonsVideoDoesNotHaveAudioStreams, nil
	case "MASTERING_OUT_OF_RANGE":
		return ExceptionReasonsMasteringOutOfRange, nil
	case "INVALID_AUDIO_TRACKS_SELECTION":
		return ExceptionReasonsInvalidAudioTracksSelection, nil
	case "PAYMENT_REQUIRED":
		return ExceptionReasonsPaymentRequired, nil
	case "FORBIDDEN":
		return ExceptionReasonsForbidden, nil
	case "INTERNAL_ERROR":
		return ExceptionReasonsInternalError, nil
	case "NONE":
		return ExceptionReasonsNone, nil
	}
	var t ExceptionReasons
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ExceptionReasons) Ptr() *ExceptionReasons {
	return &e
}

type Formalities = int

type Gender = int

type GetProbeStreamIn struct {
	URL        string  `json:"url" url:"url"`
	Passphrase *string `json:"passphrase,omitempty" url:"passphrase,omitempty"`
	StreamID   *string `json:"stream_id,omitempty" url:"stream_id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetProbeStreamIn) UnmarshalJSON(data []byte) error {
	type unmarshaler GetProbeStreamIn
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetProbeStreamIn(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetProbeStreamIn) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetProbeStreamOut struct {
	VideoStreams []*VideoStream `json:"video_streams,omitempty" url:"video_streams,omitempty"`
	AudioStreams []*AudioStream `json:"audio_streams,omitempty" url:"audio_streams,omitempty"`
	DataStreams  []*DataStream  `json:"data_streams,omitempty" url:"data_streams,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetProbeStreamOut) UnmarshalJSON(data []byte) error {
	type unmarshaler GetProbeStreamOut
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetProbeStreamOut(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetProbeStreamOut) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type HTTPValidationError struct {
	Detail []*ValidationError `json:"detail,omitempty" url:"detail,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HTTPValidationError) UnmarshalJSON(data []byte) error {
	type unmarshaler HTTPValidationError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HTTPValidationError(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HTTPValidationError) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type Languages = int

type OrchestratorPipelineCallResult struct {
	TaskID *string `json:"task_id,omitempty" url:"task_id,omitempty"`

	_rawJSON json.RawMessage
}

func (o *OrchestratorPipelineCallResult) UnmarshalJSON(data []byte) error {
	type unmarshaler OrchestratorPipelineCallResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrchestratorPipelineCallResult(value)
	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrchestratorPipelineCallResult) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrchestratorPipelineResult struct {
	Status          TaskStatus                                 `json:"status,omitempty" url:"status,omitempty"`
	RunID           *int                                       `json:"run_id,omitempty" url:"run_id,omitempty"`
	ExceptionReason *OrchestratorPipelineResultExceptionReason `json:"exception_reason,omitempty" url:"exception_reason,omitempty"`
	Message         *OrchestratorPipelineResultMessage         `json:"message,omitempty" url:"message,omitempty"`

	_rawJSON json.RawMessage
}

func (o *OrchestratorPipelineResult) UnmarshalJSON(data []byte) error {
	type unmarshaler OrchestratorPipelineResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrchestratorPipelineResult(value)
	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrchestratorPipelineResult) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrchestratorPipelineResultExceptionReason struct {
	typeName         string
	String           string
	ExceptionReasons ExceptionReasons
}

func NewOrchestratorPipelineResultExceptionReasonFromString(value string) *OrchestratorPipelineResultExceptionReason {
	return &OrchestratorPipelineResultExceptionReason{typeName: "string", String: value}
}

func NewOrchestratorPipelineResultExceptionReasonFromExceptionReasons(value ExceptionReasons) *OrchestratorPipelineResultExceptionReason {
	return &OrchestratorPipelineResultExceptionReason{typeName: "exceptionReasons", ExceptionReasons: value}
}

func (o *OrchestratorPipelineResultExceptionReason) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		o.typeName = "string"
		o.String = valueString
		return nil
	}
	var valueExceptionReasons ExceptionReasons
	if err := json.Unmarshal(data, &valueExceptionReasons); err == nil {
		o.typeName = "exceptionReasons"
		o.ExceptionReasons = valueExceptionReasons
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OrchestratorPipelineResultExceptionReason) MarshalJSON() ([]byte, error) {
	switch o.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "string":
		return json.Marshal(o.String)
	case "exceptionReasons":
		return json.Marshal(o.ExceptionReasons)
	}
}

type OrchestratorPipelineResultExceptionReasonVisitor interface {
	VisitString(string) error
	VisitExceptionReasons(ExceptionReasons) error
}

func (o *OrchestratorPipelineResultExceptionReason) Accept(visitor OrchestratorPipelineResultExceptionReasonVisitor) error {
	switch o.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "string":
		return visitor.VisitString(o.String)
	case "exceptionReasons":
		return visitor.VisitExceptionReasons(o.ExceptionReasons)
	}
}

type OrchestratorPipelineResultMessage struct {
	typeName         string
	StringUnknownMap map[string]interface{}
	String           string
}

func NewOrchestratorPipelineResultMessageFromStringUnknownMap(value map[string]interface{}) *OrchestratorPipelineResultMessage {
	return &OrchestratorPipelineResultMessage{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func NewOrchestratorPipelineResultMessageFromString(value string) *OrchestratorPipelineResultMessage {
	return &OrchestratorPipelineResultMessage{typeName: "string", String: value}
}

func (o *OrchestratorPipelineResultMessage) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		o.typeName = "stringUnknownMap"
		o.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		o.typeName = "string"
		o.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OrchestratorPipelineResultMessage) MarshalJSON() ([]byte, error) {
	switch o.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "stringUnknownMap":
		return json.Marshal(o.StringUnknownMap)
	case "string":
		return json.Marshal(o.String)
	}
}

type OrchestratorPipelineResultMessageVisitor interface {
	VisitStringUnknownMap(map[string]interface{}) error
	VisitString(string) error
}

func (o *OrchestratorPipelineResultMessage) Accept(visitor OrchestratorPipelineResultMessageVisitor) error {
	switch o.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(o.StringUnknownMap)
	case "string":
		return visitor.VisitString(o.String)
	}
}

type OverdubConfig struct {
	// Proportion of the original audio (0.0 to 1.0).
	OriginalAudioGain *float64 `json:"original_audio_gain,omitempty" url:"original_audio_gain,omitempty"`
	// Proportion of the background audio (0.0 to 1.0).
	BackgroundAudioGain *float64 `json:"background_audio_gain,omitempty" url:"background_audio_gain,omitempty"`
	// Cross-fade duration in seconds (0.0 to 5.0).
	FadeTime *float64 `json:"fade_time,omitempty" url:"fade_time,omitempty"`
	// Proportion of the fallback audio (0.0 to 1.0) (for streaming only).
	FallbackAudioGain *float64 `json:"fallback_audio_gain,omitempty" url:"fallback_audio_gain,omitempty"`

	_rawJSON json.RawMessage
}

func (o *OverdubConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler OverdubConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OverdubConfig(value)
	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OverdubConfig) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type RevoicingOption string

const (
	RevoicingOptionNone      RevoicingOption = "none"
	RevoicingOptionBestModel RevoicingOption = "best_model"
	RevoicingOptionFastModel RevoicingOption = "fast_model"
)

func NewRevoicingOptionFromString(s string) (RevoicingOption, error) {
	switch s {
	case "none":
		return RevoicingOptionNone, nil
	case "best_model":
		return RevoicingOptionBestModel, nil
	case "fast_model":
		return RevoicingOptionFastModel, nil
	}
	var t RevoicingOption
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RevoicingOption) Ptr() *RevoicingOption {
	return &r
}

type RunIDsRequestPayload struct {
	RunIDs []int `json:"run_ids,omitempty" url:"run_ids,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RunIDsRequestPayload) UnmarshalJSON(data []byte) error {
	type unmarshaler RunIDsRequestPayload
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RunIDsRequestPayload(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RunIDsRequestPayload) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type SegmentingOption string

const (
	SegmentingOptionNone      SegmentingOption = "none"
	SegmentingOptionLoudness  SegmentingOption = "loudness"
	SegmentingOptionBestModel SegmentingOption = "best_model"
	SegmentingOptionFastModel SegmentingOption = "fast_model"
)

func NewSegmentingOptionFromString(s string) (SegmentingOption, error) {
	switch s {
	case "none":
		return SegmentingOptionNone, nil
	case "loudness":
		return SegmentingOptionLoudness, nil
	case "best_model":
		return SegmentingOptionBestModel, nil
	case "fast_model":
		return SegmentingOptionFastModel, nil
	}
	var t SegmentingOption
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SegmentingOption) Ptr() *SegmentingOption {
	return &s
}

type SourceStream struct {
	Language              Languages       `json:"language" url:"language"`
	URL                   string          `json:"url" url:"url"`
	Category              *StreamCategory `json:"category,omitempty" url:"category,omitempty"`
	Passphrase            *string         `json:"passphrase,omitempty" url:"passphrase,omitempty"`
	Streamid              *string         `json:"streamid,omitempty" url:"streamid,omitempty"`
	NumberOfStreams       *int            `json:"number_of_streams,omitempty" url:"number_of_streams,omitempty"`
	AudioStream           *int            `json:"audio_stream,omitempty" url:"audio_stream,omitempty"`
	BackgroundAudioStream *int            `json:"background_audio_stream,omitempty" url:"background_audio_stream,omitempty"`
	Latency               *int            `json:"latency,omitempty" url:"latency,omitempty"`
	RelayInput            *bool           `json:"relay_input,omitempty" url:"relay_input,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SourceStream) UnmarshalJSON(data []byte) error {
	type unmarshaler SourceStream
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SourceStream(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SourceStream) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StreamCategory = int

type StreamType = int

type StreamURLForLanguages struct {
	Languages []Languages `json:"languages,omitempty" url:"languages,omitempty"`
	URL       string      `json:"url" url:"url"`

	_rawJSON json.RawMessage
}

func (s *StreamURLForLanguages) UnmarshalJSON(data []byte) error {
	type unmarshaler StreamURLForLanguages
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StreamURLForLanguages(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StreamURLForLanguages) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type TargetStream struct {
	Languages          []Languages `json:"languages,omitempty" url:"languages,omitempty"`
	URL                string      `json:"url" url:"url"`
	Type               StreamType  `json:"type" url:"type"`
	Passphrase         *string     `json:"passphrase,omitempty" url:"passphrase,omitempty"`
	Streamid           *string     `json:"streamid,omitempty" url:"streamid,omitempty"`
	Pids               []*int      `json:"pids,omitempty" url:"pids,omitempty"`
	TranscodeVideo     *bool       `json:"transcode_video,omitempty" url:"transcode_video,omitempty"`
	EmbedSubtitles     *bool       `json:"embed_subtitles,omitempty" url:"embed_subtitles,omitempty"`
	AudioCodec         *string     `json:"audio_codec,omitempty" url:"audio_codec,omitempty"`
	AudioBitrate       *string     `json:"audio_bitrate,omitempty" url:"audio_bitrate,omitempty"`
	AudioChannelLayout *string     `json:"audio_channel_layout,omitempty" url:"audio_channel_layout,omitempty"`
	Latency            *int        `json:"latency,omitempty" url:"latency,omitempty"`
	ConstantBitrate    *bool       `json:"constant_bitrate,omitempty" url:"constant_bitrate,omitempty"`
	RelayOutput        *bool       `json:"relay_output,omitempty" url:"relay_output,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TargetStream) UnmarshalJSON(data []byte) error {
	type unmarshaler TargetStream
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TargetStream(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TargetStream) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TaskStatus string

const (
	TaskStatusSuccess TaskStatus = "SUCCESS"
	TaskStatusPending TaskStatus = "PENDING"
	TaskStatusError   TaskStatus = "ERROR"
)

func NewTaskStatusFromString(s string) (TaskStatus, error) {
	switch s {
	case "SUCCESS":
		return TaskStatusSuccess, nil
	case "PENDING":
		return TaskStatusPending, nil
	case "ERROR":
		return TaskStatusError, nil
	}
	var t TaskStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TaskStatus) Ptr() *TaskStatus {
	return &t
}

type TranscribingOption string

const (
	TranscribingOptionNone      TranscribingOption = "none"
	TranscribingOptionBestModel TranscribingOption = "best_model"
	TranscribingOptionFastModel TranscribingOption = "fast_model"
)

func NewTranscribingOptionFromString(s string) (TranscribingOption, error) {
	switch s {
	case "none":
		return TranscribingOptionNone, nil
	case "best_model":
		return TranscribingOptionBestModel, nil
	case "fast_model":
		return TranscribingOptionFastModel, nil
	}
	var t TranscribingOption
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TranscribingOption) Ptr() *TranscribingOption {
	return &t
}

type Transcript struct {
	Start   float64 `json:"start" url:"start"`
	End     float64 `json:"end" url:"end"`
	Text    string  `json:"text" url:"text"`
	Speaker string  `json:"speaker" url:"speaker"`

	_rawJSON json.RawMessage
}

func (t *Transcript) UnmarshalJSON(data []byte) error {
	type unmarshaler Transcript
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Transcript(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *Transcript) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TranslatingOption string

const (
	TranslatingOptionNone      TranslatingOption = "none"
	TranslatingOptionBestModel TranslatingOption = "best_model"
	TranslatingOptionFastModel TranslatingOption = "fast_model"
)

func NewTranslatingOptionFromString(s string) (TranslatingOption, error) {
	switch s {
	case "none":
		return TranslatingOptionNone, nil
	case "best_model":
		return TranslatingOptionBestModel, nil
	case "fast_model":
		return TranslatingOptionFastModel, nil
	}
	var t TranslatingOption
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TranslatingOption) Ptr() *TranslatingOption {
	return &t
}

type ValidationError struct {
	Loc  []*ValidationErrorLocItem `json:"loc,omitempty" url:"loc,omitempty"`
	Msg  string                    `json:"msg" url:"msg"`
	Type string                    `json:"type" url:"type"`

	_rawJSON json.RawMessage
}

func (v *ValidationError) UnmarshalJSON(data []byte) error {
	type unmarshaler ValidationError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = ValidationError(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *ValidationError) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type ValidationErrorLocItem struct {
	typeName string
	String   string
	Integer  int
}

func NewValidationErrorLocItemFromString(value string) *ValidationErrorLocItem {
	return &ValidationErrorLocItem{typeName: "string", String: value}
}

func NewValidationErrorLocItemFromInteger(value int) *ValidationErrorLocItem {
	return &ValidationErrorLocItem{typeName: "integer", Integer: value}
}

func (v *ValidationErrorLocItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typeName = "string"
		v.String = valueString
		return nil
	}
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		v.typeName = "integer"
		v.Integer = valueInteger
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v ValidationErrorLocItem) MarshalJSON() ([]byte, error) {
	switch v.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return json.Marshal(v.String)
	case "integer":
		return json.Marshal(v.Integer)
	}
}

type ValidationErrorLocItemVisitor interface {
	VisitString(string) error
	VisitInteger(int) error
}

func (v *ValidationErrorLocItem) Accept(visitor ValidationErrorLocItemVisitor) error {
	switch v.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return visitor.VisitString(v.String)
	case "integer":
		return visitor.VisitInteger(v.Integer)
	}
}

type VideoStream struct {
	Index          int     `json:"index" url:"index"`
	CodecName      string  `json:"codec_name" url:"codec_name"`
	CodecLongName  string  `json:"codec_long_name" url:"codec_long_name"`
	CodecTagString *string `json:"codec_tag_string,omitempty" url:"codec_tag_string,omitempty"`
	CodecTag       *string `json:"codec_tag,omitempty" url:"codec_tag,omitempty"`
	Profile        *string `json:"profile,omitempty" url:"profile,omitempty"`
	Width          *int    `json:"width,omitempty" url:"width,omitempty"`
	Height         *int    `json:"height,omitempty" url:"height,omitempty"`
	IsAvc          *bool   `json:"is_avc,omitempty" url:"is_avc,omitempty"`
	ID             *string `json:"id,omitempty" url:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (v *VideoStream) UnmarshalJSON(data []byte) error {
	type unmarshaler VideoStream
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VideoStream(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VideoStream) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}
