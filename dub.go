// This file was auto-generated by Fern from our API Definition.

package cambai

import (
	json "encoding/json"
	fmt "fmt"
	core "sdk/core"
)

type EndToEndDubbingRequestPayload struct {
	RunID                   *int        `json:"-" url:"run_id,omitempty"`
	ProjectName             *string     `json:"project_name,omitempty" url:"project_name,omitempty"`
	ProjectDescription      *string     `json:"project_description,omitempty" url:"project_description,omitempty"`
	FolderID                *int        `json:"folder_id,omitempty" url:"folder_id,omitempty"`
	VideoURL                string      `json:"video_url" url:"video_url"`
	SourceLanguage          Languages   `json:"source_language" url:"source_language"`
	TargetLanguage          *Languages  `json:"target_language,omitempty" url:"target_language,omitempty"`
	TargetLanguages         []Languages `json:"target_languages,omitempty" url:"target_languages,omitempty"`
	SelectedAudioTracks     []int       `json:"selected_audio_tracks,omitempty" url:"selected_audio_tracks,omitempty"`
	AddOutputAsAnAudioTrack *bool       `json:"add_output_as_an_audio_track,omitempty" url:"add_output_as_an_audio_track,omitempty"`
	ChosenDictionaries      []int       `json:"chosen_dictionaries,omitempty" url:"chosen_dictionaries,omitempty"`
	AiOptimization          *bool       `json:"ai_optimization,omitempty" url:"ai_optimization,omitempty"`
}

type DubbedOutputInAltFormatRequestPayload struct {
	OutputFormat *DubbedOutputInAltFormatRequestPayloadOutputFormat `json:"output_format,omitempty" url:"output_format,omitempty"`
}

type GetDubbedOutputInAltFormatStatusDubAltFormatTaskIDGetRequest struct {
	RunID *int `json:"-" url:"run_id,omitempty"`
}

type GetDubbedRunInfoDubResultRunIDGetRequest struct {
}

type GetDubbedRunTranscriptTranscriptRunIDLanguageGetRequest struct {
	// Format to use for the transcription. Either `srt`, `vtt` or `txt`. Defaults to `txt`.
	FormatType *TranscriptFileFormat `json:"-" url:"format_type,omitempty"`
	// Data type for the transcription being returned. Returns the raw data of the transcription or a presigned url for the file that holds the transcription data.
	DataType *TranscriptDataType `json:"-" url:"data_type,omitempty"`
}

type GetDubbingRunsResultsDubbingResultsPostRequest struct {
	Traceparent *string               `json:"-" url:"-"`
	RunID       *int                  `json:"-" url:"run_id,omitempty"`
	Body        *RunIDsRequestPayload `json:"-" url:"-"`
}

func (g *GetDubbingRunsResultsDubbingResultsPostRequest) UnmarshalJSON(data []byte) error {
	body := new(RunIDsRequestPayload)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	g.Body = body
	return nil
}

func (g *GetDubbingRunsResultsDubbingResultsPostRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(g.Body)
}

type GetEndToEndDubbingStatusDubTaskIDGetRequest struct {
	RunID *int `json:"-" url:"run_id,omitempty"`
}

type PollDiscordDubTaskDiscordDubTaskIDGetRequest struct {
	RunID *int `json:"-" url:"run_id,omitempty"`
}

type PollTwitterDubTaskTwitterDubTaskIDGetRequest struct {
	RunID *int `json:"-" url:"run_id,omitempty"`
}

type AudioOutputType string

const (
	AudioOutputTypeFlac AudioOutputType = "flac"
	AudioOutputTypeWav  AudioOutputType = "wav"
	AudioOutputTypeMp3  AudioOutputType = "mp3"
	AudioOutputTypeAac  AudioOutputType = "aac"
	AudioOutputTypeM4A  AudioOutputType = "m4a"
)

func NewAudioOutputTypeFromString(s string) (AudioOutputType, error) {
	switch s {
	case "flac":
		return AudioOutputTypeFlac, nil
	case "wav":
		return AudioOutputTypeWav, nil
	case "mp3":
		return AudioOutputTypeMp3, nil
	case "aac":
		return AudioOutputTypeAac, nil
	case "m4a":
		return AudioOutputTypeM4A, nil
	}
	var t AudioOutputType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AudioOutputType) Ptr() *AudioOutputType {
	return &a
}

type DubbingResult struct {
	AudioURL   string        `json:"audio_url" url:"audio_url"`
	Transcript []*Transcript `json:"transcript,omitempty" url:"transcript,omitempty"`
	VideoURL   *string       `json:"video_url,omitempty" url:"video_url,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DubbingResult) UnmarshalJSON(data []byte) error {
	type unmarshaler DubbingResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DubbingResult(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DubbingResult) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type TranscriptDataType string

const (
	TranscriptDataTypeRawData TranscriptDataType = "raw_data"
	TranscriptDataTypeFile    TranscriptDataType = "file"
)

func NewTranscriptDataTypeFromString(s string) (TranscriptDataType, error) {
	switch s {
	case "raw_data":
		return TranscriptDataTypeRawData, nil
	case "file":
		return TranscriptDataTypeFile, nil
	}
	var t TranscriptDataType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TranscriptDataType) Ptr() *TranscriptDataType {
	return &t
}

type TranscriptFileFormat string

const (
	TranscriptFileFormatSrt TranscriptFileFormat = "srt"
	TranscriptFileFormatVtt TranscriptFileFormat = "vtt"
	TranscriptFileFormatTxt TranscriptFileFormat = "txt"
)

func NewTranscriptFileFormatFromString(s string) (TranscriptFileFormat, error) {
	switch s {
	case "srt":
		return TranscriptFileFormatSrt, nil
	case "vtt":
		return TranscriptFileFormatVtt, nil
	case "txt":
		return TranscriptFileFormatTxt, nil
	}
	var t TranscriptFileFormat
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TranscriptFileFormat) Ptr() *TranscriptFileFormat {
	return &t
}

type VideoOutputTypeWithoutAvi string

const (
	VideoOutputTypeWithoutAviMkv VideoOutputTypeWithoutAvi = "mkv"
	VideoOutputTypeWithoutAviMp4 VideoOutputTypeWithoutAvi = "mp4"
	VideoOutputTypeWithoutAviMov VideoOutputTypeWithoutAvi = "mov"
	VideoOutputTypeWithoutAviMxf VideoOutputTypeWithoutAvi = "mxf"
)

func NewVideoOutputTypeWithoutAviFromString(s string) (VideoOutputTypeWithoutAvi, error) {
	switch s {
	case "mkv":
		return VideoOutputTypeWithoutAviMkv, nil
	case "mp4":
		return VideoOutputTypeWithoutAviMp4, nil
	case "mov":
		return VideoOutputTypeWithoutAviMov, nil
	case "mxf":
		return VideoOutputTypeWithoutAviMxf, nil
	}
	var t VideoOutputTypeWithoutAvi
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VideoOutputTypeWithoutAvi) Ptr() *VideoOutputTypeWithoutAvi {
	return &v
}

type DubbedOutputInAltFormatRequestPayloadOutputFormat struct {
	typeName                  string
	AudioOutputType           AudioOutputType
	VideoOutputTypeWithoutAvi VideoOutputTypeWithoutAvi
}

func NewDubbedOutputInAltFormatRequestPayloadOutputFormatFromAudioOutputType(value AudioOutputType) *DubbedOutputInAltFormatRequestPayloadOutputFormat {
	return &DubbedOutputInAltFormatRequestPayloadOutputFormat{typeName: "audioOutputType", AudioOutputType: value}
}

func NewDubbedOutputInAltFormatRequestPayloadOutputFormatFromVideoOutputTypeWithoutAvi(value VideoOutputTypeWithoutAvi) *DubbedOutputInAltFormatRequestPayloadOutputFormat {
	return &DubbedOutputInAltFormatRequestPayloadOutputFormat{typeName: "videoOutputTypeWithoutAvi", VideoOutputTypeWithoutAvi: value}
}

func (d *DubbedOutputInAltFormatRequestPayloadOutputFormat) UnmarshalJSON(data []byte) error {
	var valueAudioOutputType AudioOutputType
	if err := json.Unmarshal(data, &valueAudioOutputType); err == nil {
		d.typeName = "audioOutputType"
		d.AudioOutputType = valueAudioOutputType
		return nil
	}
	var valueVideoOutputTypeWithoutAvi VideoOutputTypeWithoutAvi
	if err := json.Unmarshal(data, &valueVideoOutputTypeWithoutAvi); err == nil {
		d.typeName = "videoOutputTypeWithoutAvi"
		d.VideoOutputTypeWithoutAvi = valueVideoOutputTypeWithoutAvi
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DubbedOutputInAltFormatRequestPayloadOutputFormat) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "audioOutputType":
		return json.Marshal(d.AudioOutputType)
	case "videoOutputTypeWithoutAvi":
		return json.Marshal(d.VideoOutputTypeWithoutAvi)
	}
}

type DubbedOutputInAltFormatRequestPayloadOutputFormatVisitor interface {
	VisitAudioOutputType(AudioOutputType) error
	VisitVideoOutputTypeWithoutAvi(VideoOutputTypeWithoutAvi) error
}

func (d *DubbedOutputInAltFormatRequestPayloadOutputFormat) Accept(visitor DubbedOutputInAltFormatRequestPayloadOutputFormatVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "audioOutputType":
		return visitor.VisitAudioOutputType(d.AudioOutputType)
	case "videoOutputTypeWithoutAvi":
		return visitor.VisitVideoOutputTypeWithoutAvi(d.VideoOutputTypeWithoutAvi)
	}
}

type GetDubbedOutputInAltFormatDubAltFormatRunIDLanguagePostResponse struct {
	typeName                       string
	StringStringMap                map[string]string
	OrchestratorPipelineCallResult *OrchestratorPipelineCallResult
}

func NewGetDubbedOutputInAltFormatDubAltFormatRunIDLanguagePostResponseFromStringStringMap(value map[string]string) *GetDubbedOutputInAltFormatDubAltFormatRunIDLanguagePostResponse {
	return &GetDubbedOutputInAltFormatDubAltFormatRunIDLanguagePostResponse{typeName: "stringStringMap", StringStringMap: value}
}

func NewGetDubbedOutputInAltFormatDubAltFormatRunIDLanguagePostResponseFromOrchestratorPipelineCallResult(value *OrchestratorPipelineCallResult) *GetDubbedOutputInAltFormatDubAltFormatRunIDLanguagePostResponse {
	return &GetDubbedOutputInAltFormatDubAltFormatRunIDLanguagePostResponse{typeName: "orchestratorPipelineCallResult", OrchestratorPipelineCallResult: value}
}

func (g *GetDubbedOutputInAltFormatDubAltFormatRunIDLanguagePostResponse) UnmarshalJSON(data []byte) error {
	var valueStringStringMap map[string]string
	if err := json.Unmarshal(data, &valueStringStringMap); err == nil {
		g.typeName = "stringStringMap"
		g.StringStringMap = valueStringStringMap
		return nil
	}
	valueOrchestratorPipelineCallResult := new(OrchestratorPipelineCallResult)
	if err := json.Unmarshal(data, &valueOrchestratorPipelineCallResult); err == nil {
		g.typeName = "orchestratorPipelineCallResult"
		g.OrchestratorPipelineCallResult = valueOrchestratorPipelineCallResult
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetDubbedOutputInAltFormatDubAltFormatRunIDLanguagePostResponse) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "stringStringMap":
		return json.Marshal(g.StringStringMap)
	case "orchestratorPipelineCallResult":
		return json.Marshal(g.OrchestratorPipelineCallResult)
	}
}

type GetDubbedOutputInAltFormatDubAltFormatRunIDLanguagePostResponseVisitor interface {
	VisitStringStringMap(map[string]string) error
	VisitOrchestratorPipelineCallResult(*OrchestratorPipelineCallResult) error
}

func (g *GetDubbedOutputInAltFormatDubAltFormatRunIDLanguagePostResponse) Accept(visitor GetDubbedOutputInAltFormatDubAltFormatRunIDLanguagePostResponseVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "stringStringMap":
		return visitor.VisitStringStringMap(g.StringStringMap)
	case "orchestratorPipelineCallResult":
		return visitor.VisitOrchestratorPipelineCallResult(g.OrchestratorPipelineCallResult)
	}
}

type GetDubbedRunInfoDubResultRunIDGetResponse struct {
	typeName               string
	DubbingResult          *DubbingResult
	StringDubbingResultMap map[string]*DubbingResult
}

func NewGetDubbedRunInfoDubResultRunIDGetResponseFromDubbingResult(value *DubbingResult) *GetDubbedRunInfoDubResultRunIDGetResponse {
	return &GetDubbedRunInfoDubResultRunIDGetResponse{typeName: "dubbingResult", DubbingResult: value}
}

func NewGetDubbedRunInfoDubResultRunIDGetResponseFromStringDubbingResultMap(value map[string]*DubbingResult) *GetDubbedRunInfoDubResultRunIDGetResponse {
	return &GetDubbedRunInfoDubResultRunIDGetResponse{typeName: "stringDubbingResultMap", StringDubbingResultMap: value}
}

func (g *GetDubbedRunInfoDubResultRunIDGetResponse) UnmarshalJSON(data []byte) error {
	valueDubbingResult := new(DubbingResult)
	if err := json.Unmarshal(data, &valueDubbingResult); err == nil {
		g.typeName = "dubbingResult"
		g.DubbingResult = valueDubbingResult
		return nil
	}
	var valueStringDubbingResultMap map[string]*DubbingResult
	if err := json.Unmarshal(data, &valueStringDubbingResultMap); err == nil {
		g.typeName = "stringDubbingResultMap"
		g.StringDubbingResultMap = valueStringDubbingResultMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetDubbedRunInfoDubResultRunIDGetResponse) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "dubbingResult":
		return json.Marshal(g.DubbingResult)
	case "stringDubbingResultMap":
		return json.Marshal(g.StringDubbingResultMap)
	}
}

type GetDubbedRunInfoDubResultRunIDGetResponseVisitor interface {
	VisitDubbingResult(*DubbingResult) error
	VisitStringDubbingResultMap(map[string]*DubbingResult) error
}

func (g *GetDubbedRunInfoDubResultRunIDGetResponse) Accept(visitor GetDubbedRunInfoDubResultRunIDGetResponseVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "dubbingResult":
		return visitor.VisitDubbingResult(g.DubbingResult)
	case "stringDubbingResultMap":
		return visitor.VisitStringDubbingResultMap(g.StringDubbingResultMap)
	}
}

type GetDubbingRunsResultsDubbingResultsPostResponseValue struct {
	typeName               string
	DubbingResult          *DubbingResult
	StringDubbingResultMap map[string]*DubbingResult
}

func NewGetDubbingRunsResultsDubbingResultsPostResponseValueFromDubbingResult(value *DubbingResult) *GetDubbingRunsResultsDubbingResultsPostResponseValue {
	return &GetDubbingRunsResultsDubbingResultsPostResponseValue{typeName: "dubbingResult", DubbingResult: value}
}

func NewGetDubbingRunsResultsDubbingResultsPostResponseValueFromStringDubbingResultMap(value map[string]*DubbingResult) *GetDubbingRunsResultsDubbingResultsPostResponseValue {
	return &GetDubbingRunsResultsDubbingResultsPostResponseValue{typeName: "stringDubbingResultMap", StringDubbingResultMap: value}
}

func (g *GetDubbingRunsResultsDubbingResultsPostResponseValue) UnmarshalJSON(data []byte) error {
	valueDubbingResult := new(DubbingResult)
	if err := json.Unmarshal(data, &valueDubbingResult); err == nil {
		g.typeName = "dubbingResult"
		g.DubbingResult = valueDubbingResult
		return nil
	}
	var valueStringDubbingResultMap map[string]*DubbingResult
	if err := json.Unmarshal(data, &valueStringDubbingResultMap); err == nil {
		g.typeName = "stringDubbingResultMap"
		g.StringDubbingResultMap = valueStringDubbingResultMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetDubbingRunsResultsDubbingResultsPostResponseValue) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "dubbingResult":
		return json.Marshal(g.DubbingResult)
	case "stringDubbingResultMap":
		return json.Marshal(g.StringDubbingResultMap)
	}
}

type GetDubbingRunsResultsDubbingResultsPostResponseValueVisitor interface {
	VisitDubbingResult(*DubbingResult) error
	VisitStringDubbingResultMap(map[string]*DubbingResult) error
}

func (g *GetDubbingRunsResultsDubbingResultsPostResponseValue) Accept(visitor GetDubbingRunsResultsDubbingResultsPostResponseValueVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "dubbingResult":
		return visitor.VisitDubbingResult(g.DubbingResult)
	case "stringDubbingResultMap":
		return visitor.VisitStringDubbingResultMap(g.StringDubbingResultMap)
	}
}
